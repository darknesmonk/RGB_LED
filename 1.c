/*****************************************************
This program was produced by the
CodeWizardAVR V2.05.0 Professional
Automatic Program Generator
© Copyright 1998-2010 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : 
Version : 
Date    : 30.08.2015
Author  : 
Company : 
Comments: 


Chip type               : ATmega8
Program type            : Application
AVR Core Clock frequency: 2,000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*****************************************************/
#define L PORTD
#include <mega8.h>
#include <delay.h>
#include <sleep.h>
#define ALL 2
flash unsigned char pp[] = {
0x88,0x31,0x26,0x21,0xC6,0x39,0x86,0x31,0x86,0x31,0x86,0x31,0x86,0x31,0xE7,0x39,0x4,0x42,0xE4,0x39,0x5,0x21,0x25,0x21,0x25,0x21,0x25,0x21,0x25,0x21,0x45,0x29,0x44,0xAD,0xE4,0x7B,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0xC6,0x18,0x64,0x94,0xA1,0xD6,0x2,0xA5,0x62,0xAD,0x62,0xAD,0x62,0xAD,0x62,0xAD,0x25,0x84,0x4,0x84,0xE0,0xFF,0xE0,0xFF,0xE0,0xFF,0xE0,0xFF,0xE0,0xFF,0xE0,0xFF,0x44,0xCE,0x44,0xAD,0x3,0xA5,0x86,0x8,0x85,0x31,0x85,0x31,0x85,0x31,0xA5,0x31,0xE7,0x39,0xA5,0x73,0xC4,0x5A,0x5,0x0,0xA5,0x10,0xA5,0x10,0xA5,0x10,0xA5,0x10,0x46,0x29,0xE6,0x20,0xA5,0x18,0x64,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x5,0x29,0x46,0x31,0xC6,0x31,0xC5,0x28,0x45,0x28,0x65,0x28,0x65,0x28,0x45,0x28,0xC5,0x28,0xA6,0x31,0x84,0x2C,0xA3,0x24,0xA5,0x29,0x64,0x2A,0x64,0x2A,0xC5,0x29,0xE3,0x23,0x64,0x2D,0x64,0x2C,0xE0,0x17,0xE0,0x17,0xE0,0x17,0xE0,0x17,0xE0,0x17,0xE0,0x17,0x63,0x26,0xC4,0x34,0xA1,0x1E,0x82,0x24,0x2,0x1D,0x2,0x1D,0xA2,0x24,0x1,0x1E,0x43,0x2E,0x86,0x32,0x65,0x29,0x6,0x28,0x6,0x28,0x6,0x28,0x6,0x28,0xC5,0x28,0xC6,0x32,0x7,0x31,0xC2,0x28,0x80,0x29,0x43,0x29,0x43,0x29,0x60,0x29,0x1,0x29,0xE6,0x30,0xA2,0x39,0x47,0x29,0xC,0x19,0x45,0x29,0x44,0x29,0xC,0x19,0x2A,0x21,0xA3,0x39,0xA9,0x31,0xDE,0x8,0x9F,0x0,0xFB,0x8,0xF9,0x8,0x9F,0x0,0xBF,0x0,0x8E,0x29,0x75,0x21,0xF6,0x10,0x26,0x29,0xF7,0x8,0xFB,0x8,0x46,0x29,0xF1,0x10,0x3B,0x19,0x73,0x21,0x50,0x21,0xA0,0x41,0x31,0x19,0x35,0x11,0xA0,0x41,0x2B,0x21,0x57,0x19,0x72,0x21,0xBF,0x0,0xFF,0x0,0xBF,0x0,0xBF,0x0,0xDF,0x0,0xBF,0x0,0x3A,0x19,0x8B,0x29,0x13,0x11,0xF5,0x10,0x13,0x11,0x13,0x11,0xF5,0x10,0xF4,0x10,0x6F,0x29,0xA4,0x31,0x60,0x31,0x60,0x31,0x60,0x31,0x60,0x31,0x60,0x31,0x60,0x31,0xA3,0x39,0x86,0x31,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x86,0x31,0x86,0x31,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x86,0x31,0x86,0x31,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x86,0x31,0x86,0x31,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x86,0x31,0x86,0x31,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x45,0x29,0x86,0x31,0x86,0x39,0x45,0x11,0x86,0x1,0x45,0x11,0x45,0x19,0x86,0x1,0x65,0x1,0x86,0x31,0xE7,0x9,0x24,0x51,0x82,0xA0,0x24,0x41,0x45,0x29,0x82,0x98,0xC3,0x78,0xC7,0x11,0xA6,0x49,0x41,0xF0,0x0,0xF8,0x61,0xD0,0x61,0xC8,0x0,0xF8,0x0,0xF8,0x65,0x71,0xE3,0xB0,0xA2,0x98,0xA6,0x1,0x82,0xA0,0x0,0xF8,0x24,0x49,0xE3,0x50,0xC3,0xD8,0x4,0xA9,0xA2,0xA0,0x65,0x39,0x0,0xF8,0x41,0xE0,0x65,0x39,0xA2,0x78,0xC3,0xD8,0xA6,0x49,0x20,0xF8,0x0,0xF8,0x41,0xE0,0x61,0xC8,0x0,0xF8,0x0,0xF8,0x65,0x79,0x65,0x1,0x24,0x49,0xC3,0x80,0x45,0x39,0x45,0x29,0xC3,0x80,0xE3,0x68,0x65,0x9,0xE7,0x41,0xA6,0x19,0xC7,0x11,0xA6,0x21,0xA6,0x29,0xC7,0x11,0xC7,0x11,0xE7,0x39
};
  volatile unsigned char count=0,step=0,sr=0;
  unsigned char rgb[38][3][8] = {0}; 
  eeprom unsigned char type;
 
// Timer1 overflow interrupt service routine
interrupt [TIM1_OVF] void timer1_ovf_isr(void)
{
// Place your code here

      
}

// Timer2 overflow interrupt service routine
interrupt [TIM2_OVF] void timer2_ovf_isr(void)
{
     
    #asm("cli")
 
        if(count>8) count=0;
    OCR2=rgb[step][0][count];      //RED
    OCR1A=rgb[step][1][count];     // GREEN
    OCR1B=rgb[step][2][count];     //BLUE    
       #asm("sei")    
              L = (1<<count++);  
}
// Timer 0 overflow interrupt service routine
interrupt [TIM0_OVF] void timer0_ovf_isr(void)
{
 TCNT0=150;
step=(step>=sr)?0:(step+1); 
               
}

// Declare your global variables here
void sleep()
{
//unsigned char x;
//x = (MCUCR & ~(1 << BODSE)) | (1 << BODS); // подготовка бит
//MCUCR = x | (1 << BODSE); // процедура отключения BOD
//MCUCR = x;
MCUCR=0x00; 
#asm("cli");
 sleep_enable(); 
 powerdown();
}
void conv(flash unsigned char *pic,unsigned int so )
{
unsigned int ii=0,c;
unsigned char i,j;
register unsigned char r=0,g=0,b=0;
sr=so/16;

for (j=0;j<=sr; j++)
{
for(i=0; i<8 ; i++)
{   if(ii>=so) ii=0;  
 c=pic[ii++]|(pic[ii++]<<8);
       
 r=(0xF800 & c)>>11;
 g=(0x07E0 & c) >>5;
 b=(0x001F & c);  
 
 rgb[j][0][i] =(float)r/31 * 80;
 rgb[j][1][i] =(float)g/63  * 80;
 rgb[j][2][i] = (float)b/31 * 80;  
 
}
}
}
void main(void)
{
unsigned char i=0;
    #asm("cli")
// Declare your local variables here

// Input/Output Ports initialization
// Port B initialization
// Func7=In Func6=In Func5=In Func4=In Func3=Out Func2=Out Func1=Out Func0=In 
// State7=T State6=T State5=T State4=T State3=0 State2=0 State1=0 State0=T 
PORTB=0x00;
DDRB=0x0E;

// Port C initialization
// Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In 
// State6=P State5=T State4=T State3=T State2=T State1=T State0=T 
PORTC=0x40;
DDRC=0x00;

// Port D initialization
// Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=Out Func1=Out Func0=Out 
// State7=0 State6=0 State5=0 State4=0 State3=0 State2=0 State1=0 State0=0 
PORTD=0x00;
DDRD=0xFF;




// Timer/Counter 0 initialization
// Clock source: System Clock
// Clock value: 250,000 kHz
TCCR0=0x03;
TCNT0=150;

// Timer/Counter 1 initialization
// Clock source: System Clock
// Clock value: 2000,000 kHz
// Mode: Fast PWM top=0x00FF
// OC1A output: Non-Inv.
// OC1B output: Non-Inv.
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer1 Overflow Interrupt: Off
// Input Capture Interrupt: Off
// Compare A Match Interrupt: Off
// Compare B Match Interrupt: Off
TCCR1A=0xF1;
//TCCR1B=0x09;
TCCR1B=0x01;
TCNT1H=0x00;
TCNT1L=0x00;
ICR1H=0x00;
ICR1L=0x00;
OCR1AH=0x00;
OCR1AL=0x00;
OCR1BH=0x00;
OCR1BL=0x00;

// Timer/Counter 2 initialization
// Clock source: System Clock
// Clock value: 2000,000 kHz
// Mode: Fast PWM top=0xFF
// OC2 output: Non-Inverted PWM
ASSR=0x00;
//TCCR2=0x79;
 TCCR2=0x71;
TCNT2=0x00;
OCR2=0x00;

// External Interrupt(s) initialization
// INT0: Off
// INT1: Off
MCUCR=0x00;

// Timer(s)/Counter(s) Interrupt(s) initialization
TIMSK=0x45;

// USART initialization
// USART disabled
UCSRB=0x00;

// Analog Comparator initialization
// Analog Comparator: Off
// Analog Comparator Input Capture by Timer/Counter 1: Off
ACSR=0x80;
SFIOR=0x00;

// ADC initialization
// ADC disabled
ADCSRA=0x00;

// SPI initialization
// SPI disabled
SPCR=0x00;

// TWI initialization
// TWI disabled
TWCR=0x00;

// Global enable interrupts
 
if ((MCUCSR & 1)) { MCUCSR=0; 

   OCR2=100;
 for (i=0; i<8; i++) {  L   =1<<i; delay_ms(100);} OCR2=OCR1A=OCR1B=0;  
  
  OCR1A=100;
 for (i=0; i<8; i++) {  L   =1<<i;  delay_ms(100); } OCR2=OCR1A=OCR1B=0;  

  OCR1B=100;
 for (i=0; i<8; i++) {  L   =1<<i;  delay_ms(100); }   OCR2=OCR1A=OCR1B=0;  
  L=0;  
  type=0;
sleep();}      


if ((MCUCSR & 2))
{
type=(type>ALL)?1:(type+1);
MCUCSR=0; if(type>=ALL) {  type=0; sleep(); }
}



  conv(pp,sizeof(pp));
   
 #asm("sei")
  while(1){     }

 
}
