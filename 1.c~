/*****************************************************
This program was produced by the
CodeWizardAVR V2.05.0 Professional
Automatic Program Generator
© Copyright 1998-2010 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : 
Version : 
Date    : 30.08.2015
Author  : 
Company : 
Comments: 


Chip type               : ATmega8
Program type            : Application
AVR Core Clock frequency: 2,000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*****************************************************/
#define L PORTD
#include <mega8.h>
#include <delay.h>
#include <sleep.h>
#define ALL 2
flash unsigned char pp[] = {
0x0,0x0,0x0,0x0,0x0,0x0,0x21,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x24,0x6A,0x5,0x6A,0xC0,0x89,0x45,0xB3,0x45,0xBB,0xC5,0xAB,0x0,0x0,0x23,0xC3,0x4,0xB3,0xE2,0xB2,0x5,0xB3,0x4,0xB3,0x24,0xB3,0x0,0x0,0x80,0x28,0xE4,0xAA,0xA8,0x72,0x72,0x8C,0x7,0x93,0x0,0x82,0x66,0xBB,0x60,0x28,0x3,0xAB,0xC2,0xB2,0xB4,0x94,0xB7,0x2,0xB9,0xAD,0xA1,0xAA,0x44,0xBB,0x2,0xBB,0x82,0xA2,0x63,0x9A,0x67,0xB3,0x30,0x4B,0xE4,0xAA,0xE0,0x89,0x61,0x9A,0x0,0x0,0x3,0xBB,0x44,0xBB,0x23,0xBB,0x23,0xBB,0x65,0xCB,0x2,0xB3,0x43,0xB3,0x23,0xCB,0x0,0x0,0x5,0xB3,0xF2,0xAC,0x56,0xAD,0xD8,0xB5,0x25,0xA3,0x23,0xAB,0x20,0x0,0x20,0x0,0x64,0xCB,0xF8,0xBD,0xD8,0x2,0x78,0xE6,0x23,0xBB,0x65,0xC3,0x0,0x0,0x0,0x0,0x0,0x0,0x61,0x8,0x0,0x0,0xE3,0xCA,0x23,0xB3,0x3,0xBB,0x44,0xCB,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x1,0x0,0xA4,0x0,0x20,0x0,0x20,0x0,0x94,0x1C,0x36,0x5,0x57,0xD,0xF6,0x4,0x36,0x5,0x0,0x8,0x40,0x0,0x50,0x24,0xDB,0x15,0xB7,0x2D,0x17,0x6,0xB4,0x4,0xF6,0x4,0x20,0x0,0x1,0x10,0x37,0x5,0xF7,0xD5,0x18,0xCE,0xDA,0xD6,0x78,0xD,0xB9,0xD,0x97,0x5,0x1B,0xE,0xF2,0x3,0xF0,0x4,0xD6,0xA,0x3A,0x15,0x57,0x5,0x99,0x1D,0x20,0x0,0xD9,0xD,0xB8,0x5,0xFA,0xD,0x58,0xD,0x36,0x5,0xF5,0x4,0x78,0x5,0xD9,0x5,0x20,0x0,0x37,0x5,0xF8,0x5,0x9A,0xD6,0x14,0x4D,0x36,0xD,0x16,0x5,0x20,0x8,0x20,0x8,0x2D,0x3,0x36,0xC6,0xF7,0x12,0xB7,0x7C,0xB8,0xD,0xB8,0x25,0x20,0x0,0x41,0x8,0x20,0x0,0xC8,0x9,0x1,0x0,0x58,0x5,0xD8,0x5,0xD9,0x5,0x16,0x1D,0x41,0x8,0x41,0x8,0x20,0x0,0x20,0x0,0x85,0x28,0xAB,0x58,0xB7,0xB2,0x99,0xCA,0x41,0x8,0x21,0x8,0x75,0xBA,0x99,0xCA,0x98,0xD2,0x79,0xCA,0x92,0x99,0x20,0x0,0x41,0x8,0x86,0x30,0x79,0xCA,0xF9,0xD5,0xF8,0xCB,0x59,0xD2,0x79,0xCA,0xF1,0x91,0x82,0x10,0xBB,0xDA,0x3B,0xE7,0xD0,0x3A,0x96,0x1B,0x38,0xC2,0x7A,0xDA,0xCF,0x71,0x46,0x30,0x9A,0xD2,0xFC,0xE2,0x56,0x72,0x78,0xC2,0x78,0xC2,0xD7,0xC2,0xCC,0x61,0x41,0x0,0xDA,0xD2,0x7D,0xEA,0x79,0xCB,0x1A,0xD4,0x58,0xC2,0xB9,0xD2,0x14,0x9B,0x41,0x8,0xBA,0xD2,0x9D,0xE6,0x9C,0xF7,0x8F,0x32,0x78,0xBA,0x18,0xBB,0x0,0x8,0x61,0x8,0x80,0x0,0xBA,0xC2,0x58,0x44,0x37,0x7A,0x37,0xC2,0x39,0xCA,0x77,0xB3,0x61,0x8,0x61,0x8,0x41,0x8,0x41,0x8,0x1,0x20,0x0,0x48,0x41,0xB0,0x41,0xB8,0x61,0x8,0x61,0x8,0x20,0x48,0x21,0xB8,0x0,0xD0,0x0,0xC8,0x22,0xA0,0x0,0x0,0x81,0x8,0x0,0x38,0x20,0xC8,0x99,0xD6,0xD7,0xED,0x0,0xC0,0x0,0xC8,0x41,0xC0,0x62,0x10,0x1,0xE8,0x7,0x8A,0xFF,0xBE,0x59,0x1B,0x20,0xC0,0x23,0xB8,0x2,0x8,0x62,0x10,0x20,0xD0,0x20,0xC8,0x61,0xC8,0x20,0xD8,0x0,0xC8,0x1,0xC8,0x81,0xB0,0x82,0x10,0x1,0xE8,0x0,0xE0,0xDA,0xD6,0xFB,0xFE,0x0,0xC8,0x0,0xD0,0x0,0x0,0x61,0x8,0x83,0xA0,0x61,0xA8,0xDC,0xCE,0xDB,0x12,0x0,0xD0,0x0,0xD8,0x42,0x81,0x82,0x10,0x61,0x8,0x0,0x8,0x1,0x0,0x61,0x80,0x40,0x0,0x0,0x0,0x0,0x0
};
  volatile unsigned char count=0,step=0,sr=0;
  unsigned char rgb[38][3][8] = {0}; 
  eeprom unsigned char type;
 
// Timer1 overflow interrupt service routine
interrupt [TIM1_OVF] void timer1_ovf_isr(void)
{
// Place your code here

      
}

// Timer2 overflow interrupt service routine
interrupt [TIM2_OVF] void timer2_ovf_isr(void)
{
     
    #asm("cli")
 
        if(count>8) count=0;
    OCR2=rgb[step][0][count];      //RED
    OCR1A=rgb[step][1][count];     // GREEN
    OCR1B=rgb[step][2][count];     //BLUE    
       #asm("sei")    
              L = (1<<count++);  
}
// Timer 0 overflow interrupt service routine
interrupt [TIM0_OVF] void timer0_ovf_isr(void)
{
 TCNT0=150;
step=(step>=sr)?0:(step+1); 
               
}

// Declare your global variables here
void sleep()
{
//unsigned char x;
//x = (MCUCR & ~(1 << BODSE)) | (1 << BODS); // подготовка бит
//MCUCR = x | (1 << BODSE); // процедура отключения BOD
//MCUCR = x;
MCUCR=0x00; 
#asm("cli");
 sleep_enable(); 
 powerdown();
}
void conv(flash unsigned char *pic,unsigned int so )
{
unsigned int ii=0,c;
unsigned char i,j;
register unsigned char r=0,g=0,b=0;
sr=so/16;

for (j=0;j<=sr; j++)
{
for(i=0; i<8 ; i++)
{   if(ii>=so) ii=0;  
 c=pic[ii++]|(pic[ii++]<<8);
       
 r=(0xF800 & c)>>11;
 g=(0x07E0 & c) >>5;
 b=(0x001F & c);  
 
 rgb[j][0][i] =(float)r/31 * 80;
 rgb[j][1][i] =(float)g/63  * 80;
 rgb[j][2][i] = (float)b/31 * 80;  
 
}
}
}
void main(void)
{
unsigned char i=0;
    #asm("cli")
// Declare your local variables here

// Input/Output Ports initialization
// Port B initialization
// Func7=In Func6=In Func5=In Func4=In Func3=Out Func2=Out Func1=Out Func0=In 
// State7=T State6=T State5=T State4=T State3=0 State2=0 State1=0 State0=T 
PORTB=0x00;
DDRB=0x0E;

// Port C initialization
// Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In 
// State6=P State5=T State4=T State3=T State2=T State1=T State0=T 
PORTC=0x40;
DDRC=0x00;

// Port D initialization
// Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=Out Func1=Out Func0=Out 
// State7=0 State6=0 State5=0 State4=0 State3=0 State2=0 State1=0 State0=0 
PORTD=0x00;
DDRD=0xFF;




// Timer/Counter 0 initialization
// Clock source: System Clock
// Clock value: 250,000 kHz
TCCR0=0x03;
TCNT0=150;

// Timer/Counter 1 initialization
// Clock source: System Clock
// Clock value: 2000,000 kHz
// Mode: Fast PWM top=0x00FF
// OC1A output: Non-Inv.
// OC1B output: Non-Inv.
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer1 Overflow Interrupt: Off
// Input Capture Interrupt: Off
// Compare A Match Interrupt: Off
// Compare B Match Interrupt: Off
TCCR1A=0xF1;
//TCCR1B=0x09;
TCCR1B=0x01;
TCNT1H=0x00;
TCNT1L=0x00;
ICR1H=0x00;
ICR1L=0x00;
OCR1AH=0x00;
OCR1AL=0x00;
OCR1BH=0x00;
OCR1BL=0x00;

// Timer/Counter 2 initialization
// Clock source: System Clock
// Clock value: 2000,000 kHz
// Mode: Fast PWM top=0xFF
// OC2 output: Non-Inverted PWM
ASSR=0x00;
//TCCR2=0x79;
 TCCR2=0x71;
TCNT2=0x00;
OCR2=0x00;

// External Interrupt(s) initialization
// INT0: Off
// INT1: Off
MCUCR=0x00;

// Timer(s)/Counter(s) Interrupt(s) initialization
TIMSK=0x45;

// USART initialization
// USART disabled
UCSRB=0x00;

// Analog Comparator initialization
// Analog Comparator: Off
// Analog Comparator Input Capture by Timer/Counter 1: Off
ACSR=0x80;
SFIOR=0x00;

// ADC initialization
// ADC disabled
ADCSRA=0x00;

// SPI initialization
// SPI disabled
SPCR=0x00;

// TWI initialization
// TWI disabled
TWCR=0x00;

// Global enable interrupts
 
if ((MCUCSR & 1)) { MCUCSR=0; 

   OCR2=100;
 for (i=0; i<8; i++) {  L   =1<<i; delay_ms(100);} OCR2=OCR1A=OCR1B=0;  
  
  OCR1A=100;
 for (i=0; i<8; i++) {  L   =1<<i;  delay_ms(100); } OCR2=OCR1A=OCR1B=0;  

  OCR1B=100;
 for (i=0; i<8; i++) {  L   =1<<i;  delay_ms(100); }   OCR2=OCR1A=OCR1B=0;  
  L=0;  
  type=0;
sleep();}      


if ((MCUCSR & 2))
{
type=(type>ALL)?1:(type+1);
MCUCSR=0; if(type>=ALL) {  type=0; sleep(); }
}



  conv(pp,sizeof(pp));
   
 #asm("sei")
  while(1){     }

 
}
